% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/jSDM_binomial_logit_lv.R
\name{jSDM_binomial_logit_lv}
\alias{jSDM_binomial_logit_lv}
\title{Binomial logistic regression with latent variables}
\usage{
jSDM_binomial_logit_lv(
  burnin = 5000,
  mcmc = 10000,
  thin = 5,
  presence_site_sp,
  site_suitability,
  site_data,
  trials,
  n_latent = 2,
  beta_start = 0,
  lambda_start = 0,
  W_start = 0,
  mu_beta = 0,
  V_beta = 1e+06,
  mu_lambda = 0,
  V_lambda = 10,
  ropt = 0.44,
  seed = 1234,
  verbose = 1
)
}
\arguments{
\item{burnin}{The number of burnin iterations for the sampler.}

\item{mcmc}{The number of Gibbs iterations for the sampler. Total number of Gibbs iterations is equal to \code{burnin+mcmc}. \code{burnin+mcmc} must be divisible by 10 and superior or equal to 100 so that the progress bar can be displayed.}

\item{thin}{The thinning interval used in the simulation. The number of mcmc iterations must be divisible by this value.}

\item{presence_site_sp}{A vector indicating the number of successes (or presences) and the absence by a zero for each species at studied sites.}

\item{site_suitability}{A one-sided formula of the form '~x1+...+xp' with p terms specifying the explicative variables for the suitability process of the model.}

\item{site_data}{data frame containing the model's explicative variables.}

\item{trials}{A vector indicating the number of trials for each site. \eqn{t_i} should be superior or equal to \eqn{y_{ij}}{y_ij}, the number of successes for observation \eqn{n}. If \eqn{t_i
=0}, then \eqn{y_{ij}=0}{y_ij=0}.}

\item{n_latent}{An integer indicating the number of latent variables.}

\item{beta_start}{Starting values for beta parameters of the suitability process must be either a scalar or a \eqn{p \times n_{species}}{p x n_species} matrix. If \code{beta_start} takes a scalar value, then that value will serve for all of the betas.}

\item{lambda_start}{Starting values for lambda parameters corresponding to the latent variables for each species must be either a scalar or a \eqn{n_{latent} \times n_{species}}{n_latent x n_species} upper triangular matrix with strictly positive values on the diagonal. If \code{lambda_start} takes a scalar value, then that value will serve for all of the lambdas except those concerned by the constraints explained above.}

\item{W_start}{Starting values for latent variables must be either a scalar or a \eqn{n_{site} \times n_{latent}}{n_site x n_latent} matrix. If \code{W_start} takes a scalar value, then that value will serve for all of the Ws.}

\item{mu_beta}{Means of the priors for the \eqn{\beta} parameters of the suitability process. \code{mu_beta} must be either a scalar or a p-length vector. If \code{mu_beta} takes a scalar value, then that value will serve as the prior mean for all of the betas. The default value is set for an uninformative prior.}

\item{V_beta}{Variances of the Normal priors for the \eqn{\beta} parameters of the suitability process. \code{V_beta} must be either a scalar or a p-length vector. If \code{V_beta} takes a scalar value, then that value will serve as the prior variance for all of the betas. The default variance is large and set to 1.0E6 for an uninformative flat prior.}

\item{mu_lambda}{Means of the Normal priors for the \eqn{\lambda}{\lambda} parameters corresponding to the latent variables. \code{mu_lambda} must be either a scalar or a n_latent-length vector. If \code{mu_lambda} takes a scalar value, then that value will serve as the prior mean for all of the lambdas. The default value is set to 0 for an uninformative prior.}

\item{V_lambda}{Variances of the Normal priors for the \eqn{\lambda}{\lambda} parameters corresponding to the latent variables. \code{V_lambda} must be either a scalar or a \eqn{n_{latent} \times n_{latent}}{n_latent x n_latent} symmetric positive semi-definite square matrix. If \code{V_lambda} takes a scalar value, then that value will serve as the prior variance for all of the lambdas, so the variance covariance matrix used in this case is diagonal with the specified value on the diagonal. The default variance is large and set to 10 for an uninformative flat prior.}

\item{ropt}{Target acceptance rate for the adaptive Metropolis algorithm. Default to 0.44.}

\item{seed}{The seed for the random number generator. Default to 1234.}

\item{verbose}{A switch (0,1) which determines whether or not the progress of the sampler is printed to the screen. Default is 1: a progress bar is printed, indicating the step (in \%) reached by the Gibbs sampler.}
}
\value{
An object of class \code{"jSDM"} acting like a list including : \tabular{ll}{
mcmc.latent \tab A list by latent variable of mcmc objects that contains the posterior samples for latent variables Ws.\cr
mcmc.sp \tab An mcmc object that contains the posterior sample of estimated species effects \eqn{\beta_j} and \eqn{\lambda_j}. This object can be summarized by functions provided by the coda package. \cr
mcmc.Deviance \tab The posterior sample of the deviance \eqn{D}, with \eqn{D=-2\log(\prod_{ij} P(y_{ij}|\beta_j,t_i,\lambda_j, W_i))}{D=-2\log(\prod_ij P(y_ij|\beta_j,t_i,\lambda_j, W_i))}, is also provided. \cr
theta_latent \tab Predictive posterior mean of the probability associated to the suitability process for each observation. \cr
model_spec \tab Various attributes of the model fitted, including the response and model matrix used, distributional assumptions as link function and family, trial sizes, hyperparameters used in the Bayesian estimation and mcmc, burnin and thin. \cr
}
}
\description{
The \code{jSDM_binomial_logit_lv} function performs a Binomial logistic regression in a Bayesian framework. The function calls a Gibbs sampler written in C++ code which uses an adaptive Metropolis algorithm to estimate the conditional posterior distribution of model's parameters.
}
\details{
We model an ecological process where the presence or absence of species \eqn{j} on site \eqn{i} is explained by habitat suitability.

\bold{Ecological process:}
\deqn{y_{ij} \sim \mathcal{B}inomial(\theta_{ij},t_i)}{y_ij ~ Binomial(theta_ij,t_i)}
\deqn{logit(\theta_{ij}) = \beta_{0j} + X_i \beta_j + W_i \lambda_j}{logit(\theta_ij) = \beta_{0j} + X_i \beta_j + W_i \lambda_j}
}
\examples{
#==============================================
# jSDM_binomial_logit_lv()
# Example with simulated data
#==============================================

#=================
#== Load libraries
library(jSDM)

#==================
#== Data simulation

#= Number of sites
nsite <- 100
#= Number of species
nsp <- 50
#= Set seed for repeatability
seed <- 1234

#= Number of visits associated to each site
set.seed(seed)
visits <- rpois(nsite,3)
visits[visits==0] <- 1

#= Ecological process (suitability)
x1 <- rnorm(nsite,0,1)
set.seed(2*seed)
x2 <- rnorm(nsite,0,1)
X <- cbind(rep(1,nsite),x1,x2)
np <- ncol(X)
set.seed(3*seed)
W <- cbind(rnorm(nsite,0,1),rnorm(nsite,0,1))
n_latent <- ncol(W)
l.zero <- 0
l.diag <- runif(2,0,2)
l.other <- runif(nsp*2-3,-2,2)
lambda.target <- matrix(c(l.diag[1],l.zero,l.other[1],
l.diag[2],l.other[-1]), byrow=TRUE, nrow=nsp)
beta.target <- matrix(runif(nsp*np,-2,2), byrow=TRUE, nrow=nsp)
logit.theta <- X \%*\% t(beta.target) + W \%*\% t(lambda.target)
theta <- inv_logit(logit.theta)
set.seed(seed)
Y <- apply(theta, 2, rbinom, n=nsite, size=visits)

#= Site-occupancy model

mod <- jSDM_binomial_logit_lv(# Chains
                              burnin=100,
                              mcmc=100,
                              thin=1,
                              # Response variable 
                              presence_site_sp=Y,
                              trials=visits,
                              # Explanatory variables
                              site_suitability=~x1+x2,
                              site_data=X,
                              n_latent=n_latent, 
                              # Starting values 
                              beta_start=0,
                              lambda_start=0,
                              # Priors 
                              mu_beta=0, V_beta=1.0E6,
                              mu_lambda=0, V_lambda=10,
                              # Various
                              seed=1234, ropt=0.44, verbose=1)

#== Outputs
#= Parameter estimates
## beta_j
# summary(mod$mcmc.sp$sp_1[,1:ncol(X)])
pdf(file=file.path(tempdir(), "Posteriors_beta_jSDM_probit_block.pdf"))
par(mfrow=c(ncol(X),2))
for (j in 1:nsp) {
  for (p in 1:ncol(X)) {
    coda::traceplot(coda::as.mcmc(
    mod$mcmc.sp[[paste0("sp_",j)]][,p]))
    coda::densplot(coda::as.mcmc(
    mod$mcmc.sp[[paste0("sp_",j)]][,p]), 
    main = paste(colnames(
    mod$mcmc.sp[[paste0("sp_",j)]])[p],
    ", species : ",j))
    abline(v=beta.target[j,p],col='red')
  }
}
dev.off()

## lambda_j
# summary(mod$mcmc.sp$sp_1[,(ncol(X)+1):(ncol(X)+n_latent)])
# summary(mod$mcmc.sp$sp_2[,(ncol(X)+1):(ncol(X)+n_latent)])
pdf(file=file.path(tempdir(), "Posteriors_lambda_jSDM_probit_block.pdf"))
par(mfrow=c(n_latent*2,2))
for (j in 1:nsp) {
  for (l in 1:n_latent) {
  coda::traceplot(coda::as.mcmc(mod$mcmc.sp
                                [[paste0("sp_",j)]][,ncol(X)+l]))
  coda::densplot(coda::as.mcmc(mod$mcmc.sp
                              [[paste0("sp_",j)]][,ncol(X)+l]), 
                 main=paste(colnames(mod$mcmc.sp[[paste0("sp_",j)]])
                 [ncol(X)+l],", species : ",j))
 abline(v=lambda.target[j,l],col='red')
  }
}
dev.off()

## W latent variables
pdf(file=file.path(tempdir(), "Posteriors_lv_jSDM_probit_block.pdf"))
par(mfrow=c(1,2))
for (l in 1:n_latent) {
plot(W[,l],
# summary(mod$mcmc.latent[[paste0("lv_",l)]])[[1]][,"Mean"],
main = paste0("Latent variable W_", l),
xlab =paste0("W_", l, " target"),
ylab =paste0("W_", l, " estimated"))
abline(a=0,b=1,col='red')
}
dev.off()

## Deviance
summary(mod$mcmc.Deviance)
plot(mod$mcmc.Deviance)

#= Predictions
# summary(mod$theta_latent)
pdf(file=file.path(tempdir(), "Pred-Init.pdf"))
plot(theta, mod$theta_latent,
    main="theta",xlab="obs", ylab="fitted")
abline(a=0 ,b=1, col="red")
dev.off()
}
\references{
\tabular{l}{
Gelfand, A. E.; Schmidt, A. M.; Wu, S.; Silander, J. A.; Latimer, A. and Rebelo, A. G. (2005) Modelling species diversity through species level hierarchical modelling. \emph{Applied Statistics}, 54, 1-20.\cr
Latimer, A. M.; Wu, S. S.; Gelfand, A. E. and Silander, J. A. (2006) Building statistical models to analyze species distributions. \emph{Ecological Applications}, 16, 33-50.\cr
}
}
\seealso{
\code{\link[coda]{plot.mcmc}}, \code{\link[coda]{summary.mcmc}}
}
\author{
\tabular{l}{
 Ghislain Vieilledent <ghislain.vieilledent@cirad.fr>\cr
Jeanne Cl√©ment <jeanne.clement16@laposte.net>\cr }
}
\keyword{MCMC,}
\keyword{Metropolis}
\keyword{algorithm}
\keyword{binomial}
\keyword{biodiversity}
\keyword{logistic}
\keyword{model}
\keyword{multivariate}
\keyword{regression}
