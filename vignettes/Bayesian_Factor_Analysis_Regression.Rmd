---
title: "Bayesian Factor Analysis Regression in R with jSDM"
output:
  bookdown::html_document2:
  #base_format: rmarkdown::html_vignette
  #highlight: tango
  number_sections: true
toc: true
toc_float: true
fig_caption: yes
link-citations: yes
bibliography: bib/biblio-jSDM.bib
biblio-style: bib/jae.bst
csl: bib/journal-of-applied-ecology.csl
pkgdown:
  as_is: true
vignette: >
 %\VignetteIndexEntry{Bayesian Factor Analysis Regression in R with jSDM}
 %\VignetteEncoding{UTF-8}
 %\VignetteEngine{knitr::rmarkdown}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  fig.align="center",
  fig.width=8, fig.height=6,
  cache=TRUE,
  comment="#>",
  highlight=TRUE,
  eval=TRUE
)
```

Factor analysis is used frequently in fields such as psychometrics, political science, and many others to identify latent (unmeasurable) traits that influence the observable behavior of people and systems.

This post will show how to add a richer covariance structure to the analysis of a simulated multivariate regression problem using factor analysis in R with `jSDM`. As we will see, specifying this model is somewhat tricky due to identifiability issues with naive model specifications.

# Simulated data

We begin by simulating the data that we will subsequently analyze. 

```{r sim-data}
# ===================================================
# Data
# ===================================================

nsp <- 50
nsite <- 150
n_latent <- 2
seed <- 123
set.seed(seed)

# Ecological process (suitability)
x1 <- rnorm(nsite,0,1)
x2 <- rnorm(nsite,0,1)
X <- cbind(rep(1,nsite),x1,x2)
colnames(X) <- c("Int","x1","x2")
np <- ncol(X)
beta.target <- t(matrix(runif(nsp*np,-2,2), byrow=TRUE, nrow=nsp))
W <- cbind(rnorm(nsite,0,1),rnorm(nsite,0,1))
mat <- t(matrix(runif(nsp*n_latent,-2,2), byrow=TRUE, nrow=nsp))
diag(mat) <- runif(n_latent,1,3)
lambda.target <- matrix(0,n_latent,nsp)
lambda.target[upper.tri(mat,diag=TRUE)] <- mat[upper.tri(mat, diag=TRUE)]
probit_theta <- X %*% beta.target + W %*% lambda.target
e <- matrix(rnorm(nsp*nsite,0,1),nsite,nsp)
Z_true <- probit_theta + e

Y <- matrix (NA, nsite,nsp)
for (i in 1:nsite){
  for (j in 1:nsp){
    if ( Z_true[i,j] > 0) {Y[i,j] <- 1}
    else {Y[i,j] <- 0}
  }
}
```

# Modeling

## First MCMC chain to identify the species $\hat{j}$

We load the `jSDM` library. 
```{r load-jSDM}
library(jSDM)
```

We now begin building a series of models of this data using `jSDM`.

```{r jSDM-model}
library(parallel)
library(doParallel)
## Make a cluster for parallel MCMCs
nchains <- 4
ncores <- nchains ## One core for each MCMC chains
clust <- makeCluster(ncores)
registerDoParallel(clust)

# Starting parameters 
beta_start <- c(-2,-1,1,2)
lambda_start <- c(2,1,-1,-2)
W_start <- c(-2,-1,1,2)
# Seeds
seed_mcmc <- c(12, 123, 1234, 12345)

# Model
mod <-
  foreach (i = 1:nchains) %dopar% {
    # Infering model parameters
    mod <- jSDM::jSDM_binomial_probit(
      # Iterations
      burnin=5000, mcmc=5000, thin=5,
      # Data
      presence_data=Y,
      site_data = X[,-1],
      site_formula = ~.,
      # Model specification 
      n_latent=2,
      site_effect="none",
      # Priors
      V_beta = 1,
      mu_beta = 0,
      V_lambda = 1,
      mu_lambda = 0,
      # Starting values
      beta_start = beta_start[i],
      lambda_start = lambda_start[i],
      W_start = W_start[i],
      # Other
      seed = seed_mcmc[i],
      verbose = 1
    )
    return(mod)
  }
# Stop cluster
stopCluster(clust)
```

### Convergence evaluation

#### Compute $\hat{R}$

We evaluate the convergence of the MCMC output in which four parallel chains are run with starting values that are overdispersed relative to the posterior distribution.
Convergence is diagnosed when the four chains have ‘forgotten’ their initial values, and the output from all chains is indistinguishable.
If the convergence diagnostic gives values of potential scale reduction factor (psrf) or $\hat{R}$
substantially above 1, its indicates lack of convergence.

```{r model-convergence}
require(coda)
arr2mcmc <- function(x) {
  return(mcmc(as.data.frame(x)))
}
mcmc_list_param <- mcmc.list(lapply(lapply(mod,"[[","mcmc.sp"), arr2mcmc))
mcmc_list_lv <- mcmc.list(lapply(lapply(mod,"[[","mcmc.latent"), arr2mcmc))
#mcmc_list_centered_lv <- mcmc.list(lapply(lapply(mcmc_list_lv, scale, scale=FALSE),arr2mcmc))

mcmc_list_beta <- mcmc_list_param[,grep("beta",colnames(mcmc_list_param[[1]]))]
mcmc_list_lambda <- mcmc.list(lapply(mcmc_list_param[,grep("lambda", grep("sp_1.lambda_2", colnames(mcmc_list_param[[1]]), invert=TRUE, value=TRUE),value=TRUE)],arr2mcmc))
#mcmc_list_centered_lambda <- mcmc.list(lapply(lapply(mcmc_list_param[,grep("lambda", grep("sp_1.lambda_2", colnames(mcmc_list_param[[1]]), invert=TRUE, value=TRUE),value=TRUE)], scale, scale=FALSE),arr2mcmc))
# Rhat
psrf_beta0 <- gelman.diag(mcmc_list_beta[,grep("Intercept",colnames(mcmc_list_beta[[1]]))])$mpsrf
psrf_beta <- gelman.diag(mcmc_list_beta[,grep("Intercept",colnames(mcmc_list_beta[[1]]),invert=TRUE)])$mpsrf
psrf_lambda <- gelman.diag(mcmc_list_lambda)$mpsrf
psrf_lv <- gelman.diag(mcmc_list_lv)$mpsrf
Rhat <- data.frame(Rhat=c(psrf_beta0, psrf_beta,psrf_lambda,psrf_lv), Variable=c("beta0","beta","lambda","W"))
# Barplot
library(ggplot2)
ggplot(Rhat, aes(x=Variable, y=Rhat)) + 
  geom_bar(fill="skyblue", stat = "identity") +
  geom_text(aes(label=round(Rhat,2)), vjust=0) +
  geom_hline(yintercept=1, color='red') +
  coord_flip() 
```

#### Identification of species $\hat{j}$

```{r identify-jhat}
# Compute Rhat for each factor loading lambda_jl
Rhat_lambda <-  gelman.diag(mcmc_list_lambda)$psrf
# Identify the species jhat which has maximum Rhat 
#jhat <- as.numeric(sub("sp_", "", sub(".lambda_.", "", names(which.max(Rhat_lambda[,1])))))
jhat <- arrayInd(arrayInd(which.max(Rhat_lambda),dim(Rhat_lambda))[1],c(n_latent,nsp))[,2]
# Store the sign of lambda_jhat
lambda_jhat_sign <- sign(colMeans(as.matrix(mcmc_list_lambda[,grep(paste0("sp_",jhat),colnames(mcmc_list_lambda[[1]]))])))
```


### Representation of results 

```{r results-pres}
## Plot trace and posterior distributions 
# beta for two first species
plot(mcmc_list_param[,1:((np+n_latent)*2)])
# lambda for two first species
plot(mcmc_list_param[, (np+1):(np+n_latent)])
plot(mcmc_list_param[, (2*np+n_latent+1):(2*(np+n_latent))])
# for species jhat
plot(mcmc_list_param[,((np+n_latent)*(jhat-1)+1):((np+n_latent)*jhat)])
plot(mcmc_list_param[,((np+n_latent)*(jhat-1)+1+np):((np+n_latent)*jhat)])
# for two first sites 
plot(mcmc_list_lv[,c(1,nsite+1)])
plot(mcmc_list_lv[,c(2,nsite+2)])
# Deviance 
plot(mcmc.list(lapply(lapply(mod,"[[","mcmc.Deviance"), arr2mcmc)))
```


```{r obs-fitted}
## Predictive posterior mean for each observation
nchains <- length(mod)
# Species effects beta and factor loadings lambda
par(mfrow=c(1,2))
for (i in 1:nchains){
  param <- matrix(unlist(lapply(mod[[i]]$mcmc.sp,colMeans)), nrow=nsp, byrow=T)
  if(i==1){
    plot(t(beta.target), param[,1:np],
         main="species effect beta",
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  }
  else{
    points(t(beta.target), param[,1:np], col=2:nchains)
  }
}

par(mfrow=c(1,2))
for (i in 1:nchains){
  param <- matrix(unlist(lapply(mod[[i]]$mcmc.sp,colMeans)), nrow=nsp, byrow=T)
  if (i==1){
    plot(t(lambda.target), param[,(np+1):(np+n_latent)],
         main="factor loadings lambda",
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  } else {
    points(t(lambda.target), param[,(np+1):(np+n_latent)],
           col=2:nchains)
  }
}
## W latent variables
mean_W <- matrix(0,nsite,n_latent)
for (i in 1:nchains){
  for (l in 1:n_latent) {
    mean_W[,l] <- summary(mod[[i]]$mcmc.latent[[paste0("lv_",l)]])[[1]][,"Mean"]
  }
  if (i==1){
    plot(W, mean_W,
         main = paste0("Latent variable W"),
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  }
  else{
    points(W, mean_W,col=2:nchains)
  }
}

# ## W latent variables
# par(mfrow=c(1,2))
# mean_W <- matrix(0,nsite,n_latent)
# for (l in 1:n_latent) {
#   for (i in 1:nchains){
#     mean_W[,l] <- summary(mod[[i]]$mcmc.latent[[paste0("lv_",l)]])[[1]][,"Mean"]
#     
#     if (i==1){
#       plot(W[,l], mean_W[,l],
#            main = paste0("Latent variable W_", l),
#            xlab ="obs", ylab ="fitted")
#       abline(a=0,b=1,col='red')
#     }
#     else{
#       points(W[,l], mean_W[,l],col=2:nchains)
#     }
#   }
# }

#= W.lambda
par(mfrow=c(1,2))
for (i in 1:nchains){
  if (i==1){
    plot(W%*%lambda.target,mean_W%*%t(param[,(np+1):(np+n_latent)]),
         main = "W.lambda",
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  }
  else{
    points(W%*%lambda.target,mean_W%*%t(param[,(np+1):(np+n_latent)])
           ,col=2:nchains)
  }
}

#= Predictions 
## probit(tetha)
plot(probit_theta, mod[[1]]$probit_theta_latent,
     main="probit(theta)",xlab="obs",ylab="fitted")
for (i in 2:nchains){
  ## probit(tetha)
  points(probit_theta, mod[[i]]$probit_theta_latent,col=c(2:nchains))
}
abline(a=0,b=1,col='red')

## tetha
plot(pnorm(probit_theta), mod[[1]]$theta_latent,
     main="theta",xlab="obs",ylab="fitted")
for (i in 2:nchains){
  points(pnorm(probit_theta), mod[[i]]$theta_latent,col=c(2:nchains))
}
abline(a=0,b=1,col='red')

## Z
plot(Z_true, mod[[1]]$Z_latent,
     main="Z_latent", xlab="obs", ylab="fitted")
for (i in 2:nchains){
  points(Z_true, mod[[i]]$Z_latent, col=2:nchains)
}
abline(a=0,b=1,col='red')
RMSE <- 0
for(i in 1:nchains){
  RMSE <- (RMSE + sqrt(sum((probit_theta - mod[[i]]$probit_theta_latent)^2)))/nchains
}
```

## Second MCMC chains whith fixed signs of factor loading $\lambda_\hat{j}$
```{r mod_corr}
## 4 MCMCs chains
nchains <- 4
# import Rcpp function 
Rcpp::sourceCpp("/home/clement/Documents/jSDM/src/Rcpp_jSDM_binomial_probit_block_lv_corr.cpp")
# Starting parameters 
beta_start <- c(-2,-1,1,2)
mat <- matrix(1,n_latent,nsp)
mat[lower.tri(mat)] <- 0
mat1 <- mat2 <- mat3 <- mat
mat1[upper.tri(mat1,diag=TRUE)]<-2
mat2[upper.tri(mat2)]<--1
mat3[upper.tri(mat3)]<--2
lambda_start <- list(mat1,mat,mat2,mat3)
W_start <- c(-2,-1,1,2)
# Seeds
seed_mcmc <- c(12, 123, 1234, 12345)

# Model

mod_corr <- list() 
for(i in 1:nchains){
  # Infering model parameters
  mod_cor <- Rcpp_jSDM_binomial_probit_lv_corr(ngibbs=10000, nthin=5, nburn=5000,
                                               Y=Y, X=X,
                                               beta_start=matrix(beta_start[i],np,nsp),
                                               V_beta=diag(rep(1,np)), mu_beta=rep(0,np),
                                               lambda_start=lambda_start[[i]],
                                               V_lambda=diag(rep(1,n_latent)), mu_lambda = rep(0,n_latent),
                                               W_start=matrix(W_start[i],nsite,n_latent), V_W=diag(rep(1,n_latent)),
                                               seed=seed_mcmc[i], verbose=0,
                                               jhat=jhat-1,
                                               target_sign=lambda_jhat_sign)
  mod_corr[[i]] <- mod_cor 
}
```
### Convergence evaluation

#### Compute $\hat{R}$

We evaluate the convergence of the MCMC output in which four parallel chains are run with starting values that are overdispersed relative to the posterior distribution.
Convergence is diagnosed when the four chains have ‘forgotten’ their initial values, and the output from all chains is indistinguishable.
If the convergence diagnostic gives values of potential scale reduction factor (psrf) or $\hat{R}$
substantially above 1, its indicates lack of convergence.

```{r model-corr-convergence}
require(coda)
arr2mcmc <- function(x) {
  return(mcmc(as.data.frame(x)))
}
mcmc_list_lv <- mcmc.list(lapply(lapply(mod_corr,"[[","W"), arr2mcmc))
#mcmc_list_centered_lv <- mcmc.list(lapply(lapply(mcmc_list_lv, scale, scale=FALSE),arr2mcmc))
varnames(mcmc_list_lv) <- paste0("lv_",rep(1:n_latent,each=nsite),".",rep(1:nsite,n_latent))
mcmc_list_beta <- mcmc.list(lapply(lapply(mod_corr,"[[","beta"), arr2mcmc))
varnames(mcmc_list_beta) <- paste0("sp_", rep(1:nsp,np),".beta_", rep(colnames(X),each=nsp))
mcmc_list_beta0 <- mcmc_list_beta[,(1:nsp)]
mcmc_list_lambda <- mcmc.list(lapply(lapply(mod_corr,"[[","lambda"), arr2mcmc))
varnames(mcmc_list_lambda) <- paste0("sp_", rep(1:nsp,n_latent),".lambda_", rep(1:n_latent,each=nsp))
# mcmc_list_centered_lambda <- mcmc.list(lapply(lapply(mcmc_list_lambda[,-(nsp+1)], scale, scale=FALSE),arr2mcmc))
# Rhat
psrf_beta <- gelman.diag(mcmc_list_beta[,-(1:nsp)])$mpsrf
psrf_beta0 <- gelman.diag(mcmc_list_beta0)$mpsrf
psrf_lambda <- gelman.diag(mcmc_list_lambda[,-(nsp+1)])$mpsrf
psrf_lv <- gelman.diag(mcmc_list_lv)$mpsrf
Rhat <- data.frame(Rhat=c(psrf_beta0,psrf_beta,psrf_lambda,psrf_lv), Variable=c("beta0","beta","lambda","W"))
# Barplot
library(ggplot2)
ggplot(Rhat, aes(x=Variable, y=Rhat)) + 
  geom_bar(fill="skyblue", stat = "identity") +
  geom_text(aes(label=round(Rhat,2)), vjust=0) +
  geom_hline(yintercept=1, color='red') +
  coord_flip() 
```

### Representation of results 


```{r results-corr}
## Plot trace and posterior distributions 
# for two first species
plot(mcmc_list_beta[,c(1,nsp+1,2*nsp+1,2,nsp+2,2*nsp+2)])
plot(mcmc_list_lambda[,1:n_latent])
plot(mcmc_list_lambda[,(nsp+1):(nsp+n_latent)])
# for jhat species
plot(mcmc_list_beta[,c(jhat,nsp+jhat, 2*nsp+jhat)])
plot(mcmc_list_lambda[,c(jhat,nsp+jhat)])
# for two first sites 
plot(mcmc_list_lv[,c(1,nsite+1)])
plot(mcmc_list_lv[,c(2,nsite+2)])
# Deviance 
mcmc_list_Deviance <- mcmc.list(lapply(lapply(mod_corr,"[[","Deviance"), arr2mcmc))
varnames(mcmc_list_Deviance) <- "Deviance"
plot(mcmc_list_Deviance)
```

```{r obs-fitted-corr}
## Predictive posterior mean for each observation
nchains <- length(mod_corr)
# Species effects beta and factor loadings lambda
par(mfrow=c(1,2))
for (i in 1:nchains){
  if(i==1){
    plot(t(beta.target), colMeans(mod_corr[[i]]$beta),
         main="species effect beta",
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  }
  else{
    points(t(beta.target), colMeans(mod_corr[[i]]$beta), col=2:nchains)
  }
}
for (i in 1:nchains){
  if (i==1){
    plot(t(lambda.target), colMeans(mod_corr[[i]]$lambda),
         main="factor loadings lambda",
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  } else {
    points(t(lambda.target), colMeans(mod_corr[[i]]$lambda),
           col=2:nchains)
  }
}
## W latent variables
par(mfrow=c(1,2))
mean_W <- matrix(0,nsite,n_latent)
for (l in 1:n_latent) {
  for (i in 1:nchains){
    mean_W <- colMeans(mod_corr[[i]]$W)
    if (i==1){
      plot(W[,l], mean_W[,l],
           main = paste0("Latent variable W_", l),
           xlab ="obs", ylab ="fitted")
      abline(a=0,b=1,col='red')
    }
    else{
      points(W[,l], mean_W[,l],col=2:nchains)
    }
  }
}

#= W.lambda
par(mfrow=c(1,2))
for (i in 1:nchains){
  if (i==1){
    plot(W%*%lambda.target,colMeans(mod_corr[[i]]$W)%*%t(colMeans(mod_corr[[i]]$lambda)),
         main = "W.lambda",
         xlab ="obs", ylab ="fitted")
    abline(a=0,b=1,col='red')
  }
  else{
    points(W%*%lambda.target,colMeans(mod_corr[[i]]$W)%*%t(colMeans(mod_corr[[i]]$lambda))
           ,col=2:nchains)
  }
}

#= Predictions 
plot(pnorm(probit_theta), mod_corr[[1]]$theta_latent,
     main="theta",xlab="obs",ylab="fitted")
for (i in 2:nchains){
  ## probit(tetha)
  points(pnorm(probit_theta), mod_corr[[i]]$theta_latent,col=c(2:nchains))
}
abline(a=0,b=1,col='red')
plot(probit_theta, mod_corr[[1]]$probit_theta_latent,
     main="probit(theta)",xlab="obs",ylab="fitted")
for (i in 2:nchains){
  ## probit(tetha)
  points(probit_theta, mod_corr[[i]]$probit_theta_latent,col=c(2:nchains))
}
abline(a=0,b=1,col='red')
## Z
plot(Z_true, mod_corr[[1]]$Z_latent,
     main="Z_latent", xlab="obs", ylab="fitted")
for (i in 2:nchains){
  points(Z_true, mod_corr[[i]]$Z_latent, col=2:nchains)
}
abline(a=0,b=1,col='red')
# RMSE
RMSE_corr <- 0
for(i in 1:nchains){
  RMSE_corr <- (RMSE_corr + sqrt(sum((probit_theta - mod_corr[[i]]$probit_theta_latent)^2)))/nchains
}
```
